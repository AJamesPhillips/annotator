# "The times they are a'changin'" - Bob Dylan
#
# Dylan is a plugin to detect when the content of the annotated page has
# changed, and attempt to resolve the issue.

class Annotator.Plugin.Dylan extends Annotator.Plugin
  # Events to be bound to the @element.
  events:
    'rangeNormalizeFail': 'resolveRange'

  resolvers: [
    'sameStructureDifferentPlace'
  ]

  resolveRange: (annotation, range, error) ->
    root = @annotator.wrapper[0]

    for resolver in @resolvers
      res = Resolvers[resolver](root, annotation, range, error)
      if res
        console.log("Success!", res, annotation.quote)

relativePathFromTo = (a, b) ->
  for i in [0...Math.min(a.length, b.length)]
    if a[i] != b[i]
      break

  commonPath = a[0...i]
  remainA = a[i...]
  remainB = b[i...]

  pathFromA = ['']
  for x in remainA
    pathFromA.push('..')
  for x in remainB
    pathFromA.push(x)

  return pathFromA

window.Resolvers = {
  sameStructureDifferentPlace: (root, annotation, range, error) ->
    if error? and error.type not in ['start', 'end']
      return false

    # Matches XPaths of the kind generated by $.fn.xpath (see
    # extensions.coffee) -- i.e. /div[1]/p[2]/strong[1]
    explicitXPath = /^(\/\S+\[\d+\])+$/;

    # If these aren't explicit XPaths, fail
    for p in ['start', 'end']
      if not explicitXPath.test(range[p])
        return false

    # Calculate the relative path from start to end
    s = range.start.split('/')
    e = range.end.split('/')

    # Walk up from the leaves, removing the explicit indices as we go, and try to
    # find two nodes with an identical relative position in the DOM.
    for i in [Math.max(s.length, e.length) - 1...0] by -1
      s[i] = s[i].split('[')[0] if s[i]?
      e[i] = e[i].split('[')[0] if e[i]?

      startNode = Range.nodeFromXPath(s.join('/'), root)
      continue unless startNode

      endNode = Range.nodeFromXPath(relativePathFromTo(s, e).join('/'), startNode)
      continue unless endNode

      newRange = $.extend({}, range, {
        start: $(startNode).xpath(root)[0]
        end: $(endNode).xpath(root)[0]
      })

      normed = new Range.SerializedRange(newRange).normalize(root)
      if annotation$.trim(normed.text())

    return false
}
